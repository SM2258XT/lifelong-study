---
title: 确保可靠传输（丢失）
updated: 2022-11-10T14:40:18
created: 2022-10-28T08:12:31
---

确保可靠传输（丢失）
2022年10月28日
8:12

**三种消息丢失场景**
1.  **生产者丢失**
    1.  事务 channel.txSelect()
MQ没有成功收到，则可以回滚事务，然后重发消息。如果MQ收到了，则可以提交事务。
1.  生产者发送确认 channel.txCommit()
    1.  单条confirm
    2.  批量confirm
    3.  异步confirm
对比：事务太耗性能，是同步的；confirm是异步的。而且两者不能共存。
1.  **MQ丢失**
开启MQ持久化，但是仍有极小的概率丢数据。

注意：必须设置两个持久化
1.  创建 queue 的时候将其设置为持久化。这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。
2.  第二个是发送消息的时候将消息的 deliveryMode 设置为 2。就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。
必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。

所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack ，你也是可以自己重发的。
1.  **消费者丢失**
手动ACK
