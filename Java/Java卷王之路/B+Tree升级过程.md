---
title: B+Tree升级过程
updated: 2022-10-05T09:34:58
created: 2022-10-04T14:24:09
---

**Hash表：O(1)**
优点：查询时效率高，甚至达到了O(1)
缺点：无法快速范围查找，只能扫描全表。
升级目的：需要找到一种还可以支持快速查找的数据结构。

**二叉树：O(log2n) 普通二分**
优点：每个节点2个分支，可以快速查找（二分），并且前/中/后序遍历是有序的
缺点：
1.  很考验根节点取值，而且一开始只有一个元素没有参照对象又很难确定取值。例如根节点取了个极小的值，那么后续加入的节点总会加到右边，树就不分叉了，此时查询效率几乎退化为数组**O(n)**。
2.  不支持范围快速查找
升级目的：需要找到一种还可以调整左右子树差距的数据结构，防止某一边徒长。

**平衡二叉树：O(log2n) - - 左右旋**
优点：通过左旋/右旋的方式，控制左右子树最多相差1来保持平衡。
缺点：
1.  时间复杂度仍和树高有关。树有多高就IO检索多少次，表数据量大（树特别高）时，查询性能很差。
例如100w条数据，耗时：log2(100w) = **20 次IO**
1.  不支持范围快速查找
升级目的：减少树高和IO，最大化利用每次IO

**BTree平衡多叉树：O(log2n) - + 矮胖**
读一个节点会IO一次。InnoDB存储引擎一次IO会读取一页（默认一页16\*1024 Byte）的数据量，而二叉树一个节点数据量也就16 Byte，每次IO浪费了太多数据（99.902%）。
因此最简单的方式就是：让节点数量变小，体型变胖。每个节点可以存储1000个索引。
再如100w条数据，耗时：log1000(100w) = **2 次IO**
优点：最大化利用每次IO
缺点：
1.  不支持范围快速查找
2.  树仍然会变高。如果节点data存的是行记录（name,birth,age），行的大小随着列数增多，节点上每个data就会变大，节点可存的data数量变少，只能增加高度。

**B+Tree改造B树：O(log2n) - + + 双向有序链表**
只在叶子节点存数据。这样键值占地小，全部存到非叶子中，就不会使树变得很高。
叶子节点使用双向指针，构成双向有序链表。当然，从叶子节点中找数据，仍然是遍历。
优点：
1.  终于支持快速范围查询。因为双向有序链表
2.  整体上会降低树的高度。因为占地小的索引在非叶子节点中被挤到一起
