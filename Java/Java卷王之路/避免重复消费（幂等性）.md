---
title: 避免重复消费（幂等性）
updated: 2022-11-10T14:40:22
created: 2022-10-03T16:25:34
---

在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id ，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列
在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重和幂等的依据，避免同一条消息被重复消费。

**重复消费不可怕，重点在于事后保证幂等性**
假设有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，不就插入了两条，这数据不就错了？
但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。
一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。

**幂等性保证**
一个请求重复来多次，你得确保对应的数据是不会改变的，不能出错。
其实还是得结合业务来思考，几个思路：
- 数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
- 写 Redis，那没问题了，反正每次都是 set，天然幂等性。
- 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
- 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
