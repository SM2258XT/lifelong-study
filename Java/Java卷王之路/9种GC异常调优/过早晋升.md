---
title: 过早晋升
updated: 2022-11-20T20:20:49
created: 2022-11-20T20:00:39
---

过早晋升一般不会直接影响GC，而是伴随着浮动垃圾、大对象担保失败等问题，不是立即发生的

**现象：**比如说Old区触发回收的阈值为80%，而几乎每次GC后就回到了10%，说明Old区中，朝生夕死的对象占了近70%！！！很可能是新生代的对象过早晋升。

**危害：**
1.  Full GC频繁，可能会有较大停顿
2.  YGC频繁，总的吞吐量下降

**原因**
1.  **年轻代过小**
大对象装不下，直接晋升
1.  **分配速率过大。**
看看是否有大量数据被加载到内存中。可以观察Mutator的分配速率，如果事故前后有明显波动，可以尝试观察网卡流量，中间件慢查询等日志。
1.  **MaxTenuringThreshold设置不合理**
设置过大：原本该晋升的对象，一直留在S区直至溢出。一旦溢出，则不会再依据年龄晋升而是直接放老年代（因为S塞不下了），导致老化机制失效

设置过小：朝生夕死的对象许多也直接进了Old，空间迅速填满又引起MajorGC

**解决策略**
1.  如果年轻代过小，则增大Young比例（不一定要增大总内存）
一般Old大小应当为活跃对象的2-3倍左右，加上浮动垃圾最终应该在3倍左右
1.  扩容VM，增加内存，定位Bug等

一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（-Xmn），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)
