---
title: 多线程常考
updated: 2022-11-20T08:19:53
created: 2022-05-12T19:38:53
---

多线程常考
2022年5月12日 星期四
下午7:38

1.  主要线程安全问题：
    1.  **可见性：缓存一致性导致；volatile解决**
    2.  **原子性：线程并发导致；CAS解决**
    3.  **有序性：编译优化导致；CAS解决**
有哪些保证多线程安全方法？

synchronized、ReentantLock、volatile、AtomicXxx

1.  什么是线程安全？servlet是线程安全的吗？
某个方法在多线程环境下能够正确处理共享数据。

Servlet不安全，单实例多线程

Controller不安全，单实例多线程（scope默认为singleton）

Struts2安全，多实例多线程，每个请求都会new一个新的action来处理

1.  **sleep和yield：**
sleep执行后进入阻塞状态，为所有的线程让出cpu，至于该怎么分配就要看优先级；而yield执行后只会给**大于等于**当前线程优先级的线程让出本次cpu，接着直接进入就绪状态等着下一次抢占。

疑问：sleep会切换到核心态吗？wait呢？

1.  锁
乐观锁（更改上锁）：每次拿数据都认为别人不会修改，所以不会上锁。只有在修改的时候会判断一下有没人改动过了。适合多读场景。

（数据库write-condition、AtomicXxx等）

悲观锁（一直上锁）：总是假设被人会修改，所以每次即使是取数据都要上锁。

（synchronized）

1.  什么是自旋？关键字：忙循环
其实还是为了优化性能。

很多synchronized里面只有一些很简单的方法，加锁解锁还是麻烦（线程阻塞涉及到用户态和核心态的切换，很笨重），于是不妨使用while循环来做忙循环，检测锁，说不定此时其他正持有锁的线程的同步方法刷的一下就执行完了立即释放，当前线程就省去了切换状态的开销了。只有运气很差，循环很久还是没得到锁的时候再阻塞。

默认的自旋次数是10次

1.  单例模式创建时的线程安全
饿汉式：安全

懒汉式：不安全

双检锁单例模式：安全

1.  CAS（V，E，N）
我要将V变量的值改为N，在该之前我先检查一下我期望的当前值是否为E。是一种乐观锁，因为只有增删的时候才上锁。

CAS导致的问题：
1.  ABA：执行过程被调包篡改，但是最终结果却恰好一样
2.  只能保证一个变量的原子性，但是多个变量就没办法（用synchronized解决）
3.  循环时间开销大：对于竞争严重的资源来说，CAS自旋概率会比较大（每个线程CAS都失败，于是都进行自旋，线程多了自旋的也多，忙等待浪费很多性能）

1.  线程池流程
