---
title: volatile和缓存一致性问题
updated: 2022-09-16T10:57:51
created: 2022-09-16T10:57:13
---

1.  为什么需要Cache：
计算机在执行程序时，每条指令都是在CPU中执行的。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存Cache。
1.  Cache和内存操作数据过程：
当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。
1.  多核CPU环境下引发的缓存一致性问题：
在多核CPU中，每条线程可能运行于不同的CPU中，而每个CPU有自己独享的Cache
1.  示例代码： i = i + 1; （i的初值为0）
2.  理想结果：两个线程分别执行该语句，总共执行了2次，最后i的正确值应该为2。
3.  可能存在下面一种情况：
    1.  初始时，两个线程分别读取i的值存入各自独享的CPU的Cache当中
    2.  线程1进行加1操作，然后把i的最新值1写入到内存。
    3.  此时线程2的Cache当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。
    4.  最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。
也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
1.  缓存一致性问题的硬件解决：
缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中的共享变量的副本是一致的。

当CPU写数据时（读数据时不会触发该协议），如果发现其他CPU的Cache中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己Cache中该变量的缓存行是无效的，那么它就会从内存重新读取。
