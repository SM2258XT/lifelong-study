---
title: volatile可见性和指令重排序
updated: 2024-09-03T17:51:29
created: 2022-05-02T15:06:18
---

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
1.  JMM（Java Memory Model）
Java内存模型，是java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别注意这个跟JVM完全不是一个东西，也不是计算机底层内存模型

JMM有以下规定：
1.  所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。
2.  每个线程还有一个自己的工作内存，保留了被线程使用的变量的工作副本。
3.  线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。
4.  不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。
正是因为这样的机制，才导致了可见性问题的存在

1.  可见性的解决方案
    1.  加锁
    2.  volatile
当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
- 如何发现失效？嗅探
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。
- 总线风暴
由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。

所以不要大量使用Volatile，至于什么时候去使用Volatile什么时候使用锁，根据场景区分。

1.  指令重排序
为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。
- as-if-serial（貌似串行语义）
不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器，Runtime和处理器都必须遵守as-if-serial语义。

但是指令重排序导致的多个线程操作之间的不可见性。
1.  volatile如何保证不被指令重排序？
java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。
1.  它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；
即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
1.  它会强制将对缓存的修改操作立即写入主存；
2.  如果是写操作，它会导致其他CPU中对应的缓存行无效。
1.  volatile只能保证可见性
无法保证原子性：一次操作，要么完全成功，要么完全失败。

假设现在有N个线程对同一个变量进行累加也是没办法保证结果是对的，因为读写这个过程并不是原子性的。

如果要解决这个问题，需要配使用Atomic原子变量类（底层是CAS + volatile）
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)
