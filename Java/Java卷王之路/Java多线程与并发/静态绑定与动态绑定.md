---
title: 静态绑定与动态绑定
updated: 2022-09-15T14:17:07
created: 2022-05-14T14:39:44
---

- 绑定
把一个方法与其所在的类/对象关联起来叫做方法的绑定。绑定分为静态绑定（前期绑定）和动态绑定（后期绑定）。
- 静态绑定：**编译期（前期绑定）**
在程序运行前就已经知道方法是属于哪个**具体类**的，在**编译期**就可以连接到类的中，定位到这个方法。
- final、private、static修饰的方法以及构造函数都是静态绑定的，不需程序运行，不需具体的实例对象就可以知道这个方法的具体内容。
- 动态绑定：**运行时（后期绑定）**
在程序运行过程中，根据具体的实例对象才能具体确定是哪个方法。
- 动态绑定是多态性得以实现的重要因素，它通过方法表来实现：
- 每个类被加载到虚拟机时，在方法区保存元数据，其中，包括一个叫做方法表（method table）的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。如果这个类重写了父类中的某个方法，则对应表项**指向新的代码实现处**。从父类继承来的方法位于子类定义的方法的前面。
- 动态绑定语句的编译、运行原理：
一句话总结：编译和运行时，各自检查的对象类型不同！编译检查显示引用，运行检查实际类型。

我们假设Father ft=new Son(); ft.say(); Son继承自Father，重写了say()。
- 编译：
向上转型时，用父类引用指向子类对象，并可以用父类引用调用子类中重写了的同名方法。但是**不能调用子类中新增的方法**，因为在代码的编译阶段，编译器通过声明对象的类型（即**引用本身的类型Father**） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。而Father类方法表中是没有子类新增的方法的，所以不能调用。

编译阶段是**确保方法的存在性**，保证程序能顺利、安全运行。
- 运行：
这里就是动态绑定机制的真正体现。

上面编译阶段在声明对象类型的方法表中查找方法，只是为了安全地通过编译（也为了检验方法是否是存在的）。而在实际运行这条语句时，在执行 Father ft=new Son(); 这一句时创建了一个Son实例对象，然后在 ft.say() 调用方法时，JVM会把刚才的son对象**压入操作数栈**，用它来进行调用。而用实例对象进行方法调用的过程就是动态绑定：根据实例对象所属的类型去查找它的方法表，找到匹配的方法进行调用。我们知道，子类中如果重写了父类的方法，则方法表中同名表项会指向子类的方法代码（子类方法会重写父类同名方法，但方法区中父类方法与子类方法的内存仍然存在且地址唯一）；若无重写，则按照父类中的方法表顺序保存在子类方法表中。故此：动态绑定根据对象的类型的方法表查找方法是一定会匹配（因为编译时在父类方法表中以及查找并匹配成功了，说明方法是存在的。这也解释了为何向上转型时父类引用不能调用子类新增的方法：在父类方法表中必须先对这个方法的存在性进行检验，如果在运行时才检验就容易出危险——可能子类中也没有这个方法）。
