---
title: synchronized锁升级
updated: 2024-09-04T11:36:35
created: 2022-05-13T19:18:36
---

**有哪些锁升级**
JDK 1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

**syncoronized和lock的区别**
synchronized相当于自动挡汽车，使用简单，可以覆盖大部分使用场景。
lock相当于手动挡汽车，如果你想玩漂移等特殊操作，就需要lock，使用相对麻烦，但可以实现一些特殊场景，如公平锁。

**锁升级**
原始的synchronized是直接使用重量级锁，导致性能很低，加入锁升级才使得synchronized性能获得很大提升。
1.  **无锁**：**直接不上锁**
可能在编译期就直接优化掉上锁的操作，非常智能**（基于逃逸分析）**
1.  **偏向锁**：**同一线程直接用**
当只有一个线程获得了锁，锁就进入偏向模式，减少同一线程反复获取锁带来的开销

MarkWord标识偏向状态，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作。
1.  **轻量级锁**（自旋锁）：**忙等待，自旋**
偏向锁出现了竞争会升级为轻量级锁。

​在偏向锁的基础上，当有其它线程要获取锁，竞争不是很激烈，锁进入轻量级锁，MarkWord标识轻量级状态，此时等待锁的线程开始自旋，即空循环等待锁释放，此过程不释放cpu。

但是系统很多线程都是等你刚刚退出的时候，就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是 JDK 1.6 引入自适应的自旋锁，让虚拟机变得更聪明。

**3.1 适应自旋锁**

自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。（自旋成功，则推算下一次大概率也会成功，于是下次增加少许自旋次数。反之亦然）
1.  **重量级锁**：**操作系统外界干预**
当线程没有获得轻量级锁时，线程会CAS自旋来获取锁，当一个线程自旋10次之后，仍然未获得锁，那么就会升级成为重量级锁。

成为重量级锁之后，线程会进入阻塞队列(EntryList)，线程不再自旋获取锁，而是由CPU进行调度，线程串行执行。

重量级锁依赖操作系统的Mutex lock实现，此时等待锁的线程挂起，当锁释放后再由操作系统唤醒重新尝试获取锁，由于借助操作系统，导致**用户态内核态切换**，此过程时间成本比较高。

补充：
1.  可重入锁
两个方法A，B锁的都是同一个对象，其中A调用B，那么某线程获取锁后进入A方法也能顺利进入B方法，即自己不会锁自己（否则synchronized修饰的方法都不能递归了)

常用的synchronized、ReentrantLock是可重入锁
1.  公平/非公平锁
从上面的描述也会发现，当某个线程释放锁，其它线程会重新竞争锁，没有先来后到，就跟抢公交一样蜂拥而上，这就是不公平，我们的synchronized就是一个非公平锁。

如果想实现公平锁，可以用ReentrantLock，他会维护一个队列，先到先得，就像排队上地铁，文明多了。

