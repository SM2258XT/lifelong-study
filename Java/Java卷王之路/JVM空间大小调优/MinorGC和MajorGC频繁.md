---
title: MinorGC和MajorGC频繁
updated: 2022-11-22T07:53:12
created: 2022-11-22T07:52:45
---

MinorGC和MajorGC频繁
2022年11月22日
7:52

**案例一：MinorGC和MajorGC频繁**
首先优化MinorGC频繁问题，通常情况下是由于新生代较小，Eden很快被填满。
**复制对象的成本**要**远高于**扫描成本，所以，单次Minor GC时间更多取决于**GC后存活对象的数量**，而非Eden区的大小。
因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。

根据GC日志，确认一下对象的生命周期分布情况
- new threshold = 2，表示**动态年龄判断**，对象的晋升年龄阈值为2。 ===\> 老年代极易混入许多朝生夕死的对象
- MajorGC之后，老年代平均300M ===\> 老年代真正的存活对象大约是300M，很少
由此可见，老年代存在大量短期临时对象，在扩容新生代后，MinorGC频率降低，对象把扩容后的新生代填满后，又可以得到充分回收，老年代的MajorGC频率也随之下降。
优化结果：扩容新生代为原来3倍，单次Minor GC时间增加小于5ms，频率下降了60%，服务响应时间TP90，TP99都下降了10ms+，服务可用性得到提升。

**动态年龄判断为什么是2**
为什么设置了MaxTenuringThreshold=15，对象仍然仅经历2次Minor GC，就晋升到老年代？
Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值。
调优前：Survivor区 = 64M，此时Survivor区中age\<=2的对象累计大小为41M，41M大于64/2=32M，所以晋升年龄阈值被设置为2，下次Minor GC时将年龄超过2的对象被晋升到老年代。
也就是说，动态年龄过小，其一原因也会是Eden过小，放不下了只能把新建的对象放Survivor，放太多超过了一半，就会影响动态年龄阈值！
