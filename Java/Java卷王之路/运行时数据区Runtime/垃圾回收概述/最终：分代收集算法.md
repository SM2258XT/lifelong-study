---
title: 最终：分代收集算法
updated: 2024-09-07T14:42:02
created: 2022-05-09T07:39:54
---

最终：分代收集算法
2022年5月9日
7:39

没有最好的算法，只有最合适的算法。不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
因此JVM将Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

之前的算法，在垃圾回收过程中，Stop the World会导致应用程序所有的线程都会挂起，等待垃圾回收的完成。如果垃圾回收时间过长，将严重影响用户体验或者系统的稳定性。
为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。

**增量收集算法基本思想**
- 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以**分阶段的方式完成标记、清理或复制工作**
- 优缺点：减少系统的停顿时间，但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

**分区算法基本思想（G1、ZGC）**
- 核心思想：一次GC并不立即扫描回收整个堆区，而是分成很多小块，每次回收一部分小块。
- 堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，**而不是整个堆空间**，从而减少一次GC所产生的停顿。
- 这种算法的好处是可以控制一次回收多少个小区间。

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
