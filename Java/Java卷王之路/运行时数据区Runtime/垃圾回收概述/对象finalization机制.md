---
title: 对象finalization机制
updated: 2022-09-14T09:13:46
created: 2022-05-08T22:27:33
---

对象finalization机制
死前套大招还可以复活（但是最多只能一次）
2022年5月8日
22:27

对象**销毁前**的回调函数：finalize()
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
- finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。
- 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：
  1.  在finalize()时可能会导致对象复活。
  2.  finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。
  3.  一个糟糕的finalize()会严重影响GC的性能，比如finalize是个死循环。
从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以在本质上不同
1.  finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收

**生存还是死亡？**
对象需要被回收时，也并非是“非死不可”的，这时候它们暂时处于**“缓刑”阶段**。
由于finalize()方法的存在，对象可能的三种状态进行区分如下：
1.  可触及的：从根节点开始，可以到达这个对象。
2.  可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
3.  不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()无论怎样只会被调用一次。

判定一个对象objA是否可回收，至少要经历**两次标记过程**：
1.  如果对象objA到GC Roots没有引用链，则进行第一次标记。
2.  进行筛选，判断此对象是否有必要执行finalize()方法
    1.  如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
    2.  如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
    3.  finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。

MAT与JProfiler的GC Roots溯源
获取 dump 文件方式
使用 MAT 查看堆内存快照
JProfiler 分析 OOM
