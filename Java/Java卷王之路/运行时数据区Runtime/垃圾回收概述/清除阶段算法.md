---
title: 清除阶段算法
updated: 2024-09-07T14:24:00
created: 2022-05-09T07:16:50
---

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
清除阶段算法
2022年5月9日
7:16

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间。
目前在JVM中比较常见的三种垃圾收集算法是：标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）

1.  标记-清除算法
    - Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中**没有**标记为可达对象，则将其回收
    - 这里所谓的**清除并不是直接置空**，而是把需要清除的对象地址保存在空闲地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就覆盖存放（类似于磁盘删除文件，不是直接删除）。
    - 标记-清除算法的缺点
      - 标记清除算法的效率不算高
      - 在进行GC的时候，需要STW停止整个应用程序，用户体验较差
      - 这种方式清理出来的空闲内存是不连续的，**产生内碎片**，需要维护一个空闲列表
    - 关于空闲列表是在为对象分配内存的时候提过：
      - 如果内存规整：采用指针碰撞的方式进行内存分配
      - 如果内存不规整：采用空闲列表分配内存虚拟机，需要维护一个空闲列表
2.  复制算法（**年轻代**）
    - 将活着的内存空间分为两块，**每次只使用其中一块**，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
    - 优点
      - 没有标记和清除过程，实现简单，运行高效
      - 复制过去以后保证空间的连续性，不会出现“碎片”问题。
    - 缺点
      - 需要两倍的内存空间。
      - 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小
3.  标记-压缩算法（**老年代**）
    - 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
第二阶段将所有的存活对象**压缩到内存的一端**，按顺序排放。之后，清理边界外所有的空间。
- 优点
  - 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
  - 消除了复制算法当中，内存减半的高额代价。
- 缺点
  - 从效率上来说，标记-整理算法要低于复制算法。
  - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）
  - 移动过程中，需要全程暂停用户应用程序。即：**STW**

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image3.png)

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image4.png)
