---
title: 堆空间分代和TLAB
updated: 2023-02-24T09:38:45
created: 2022-05-06T11:02:57
---

为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
其实不分代完全可以，分代的唯一理由就是**优化GC性能**。
如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行**无差别扫描，性能低**
而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）

**使用TLAB**为对象分配内存**而不是互斥锁**（保证线程安全）
堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。因此使用TLAB可以避免一系列的非线程安全问题

什么是 TLAB（Thread Local Allocation Buffer）
从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配策略**。
一旦对象在TLAB空间**分配内存失败时**，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而**直接在Eden空间中分配内存**。
默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%
尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。

TLAB总结：
哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定
TLAB并非解决多线程数据共享安全性问题，而是解决多线程争抢内存空间分配的问题。可以不再加锁，提升性能
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image3.png)
