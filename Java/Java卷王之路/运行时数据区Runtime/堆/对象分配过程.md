---
title: 对象分配过程
updated: 2024-09-06T15:21:45
created: 2022-05-06T07:54:55
---

对象分配过程
2022年5月6日
7:54

1.  new的对象先放伊甸园区。此区有大小限制。
2.  当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对**新生代**进行垃圾回收（**YGC / Minor GC**），将新生代中的不再被其他对象所引用的对象进行销毁。
再加载新对象放到伊甸园区。然后将伊甸园中的剩余对象移动到幸存者0区。同时我们给每个对象设置了一个**年龄计数器**，每经过一次回收后还存在的对象，将其年龄加 1。
1.  如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。
2.  如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区，一直循环。
3.  啥时候能去养老区呢？可以设置次数。**默认是15次**。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：-XX:MaxTenuringThreshold=N进行设置
4.  在养老区，相对悠闲。当养老区内存不足时，再次触发GC：**Major GC**，进行养老区的内存清理
5.  若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生**OOM异常**。

对象分配的特殊情况：
1.  如果来了一个新对象，先看看 Eden 是否放的下？
如果 Eden 放得下，则直接放到 Eden 区

如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？
1.  将对象放到老年区又有两种情况：
如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代

那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM
1.  如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

对象内存分配策略
针对不同年龄段的对象分配原则如下所示：
1.  优先分配到Eden：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢
2.  大对象直接分配到老年代：尽量避免程序中出现过多的大对象
3.  长期存活的对象分配到老年代
4.  动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
5.  空间分配担保： -XX:HandlePromotionFailure 。

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
