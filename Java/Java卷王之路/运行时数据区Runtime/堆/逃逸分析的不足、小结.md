---
title: 逃逸分析的不足、小结
updated: 2022-09-13T16:05:25
created: 2022-05-06T12:50:07
---

1.  老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；
2.  如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；
3.  如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。
4.  当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。
5.  当GC发生在老年代时则被称为Major GC或者Full GC。
6.  一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。

**逃逸分析的不足**
1\. 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。
2\. 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。
4\. 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。
5\. 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，\*\*Oracle Hotspot JVM中并未这么做\*\*（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，\*\*所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上\*\*。
6\. 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是\*\*intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配\*\*，\*\*所以这一点同样符合前面一点的结论：**对象实例都是分配在堆上，包括字符串缓存**\*\*。
