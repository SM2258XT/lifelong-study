---
title: 方法区的垃圾回收
updated: 2022-05-13T20:17:08
created: 2022-05-07T09:06:05
---

方法区的垃圾回收
2022年5月7日
9:06

一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。
方法区的垃圾收集主要回收两部分内容：常量池中废弃的**常量**（字面量和符号引用）和不再使用的**类型**。
只要常量池中的常量没有被任何地方引用，就可以被回收。回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）

类卸载（很苛刻）：
- 需要同时满足下面三个条件：
  1.  该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
  2.  加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  3.  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
- Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了\`-Xnoclassgc\`参数进行控制，还可以使用\`-verbose:class\` 以及 \`-XX：+TraceClass-Loading\`、\`-XX：+TraceClassUnLoading\`查看类加载和卸载信息
- 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。
直接内存
不是虚拟机运行时数据区的一部分，是在直接**向系统申请**的内存区间。

来源于NIO，Java的NIO库允许Java程序使用直接内存，用于数据缓冲区通过存在堆中的DirectByteBuffer操作Native内存

通常，访问直接内存的速度会优于Java堆。即读写性能高。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)
