---
title: 方法区演进细节
updated: 2022-05-13T20:17:08
created: 2022-05-07T08:53:34
---

方法区演进细节
2022年5月7日
8:53
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image3.png)
1\. 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
2\. 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
3\. 这项改动是很有必要的，原因有：
1\. 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。\`Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space\`而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。
2\. 对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低\*\*Full GC\*\*
1\. 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
2\. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻\*\*。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。
字符串常量池
字符串常量池 StringTable 为什么要调整位置？
JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。
这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

静态变量放在哪里？对象实体在哪里放着？ private static byte\[\] arr = new byte\[1024 \* 1024 \* 100\];//100MB
结论：
静态引用对应的对象实体(也就是这个new byte\[1024 \* 1024 \* 100\])始终都存在堆空间，
只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化
