---
title: resize()和树化
updated: 2023-02-23T09:39:26
created: 2022-09-15T11:51:12
---

**职责：**
1.  （如果为空）初始化table数组
2.  计算新的容量和扩容阀值，并创建新的 table 数组
3.  将老的 table 复制到新的 table 数组中

**putKV分成三种情况：**
如果 e 节点只有一个元素，直接赋值给新的 table 即可。这是一个优化操作，无论 Node 节点是链表还是红黑树。
如果 e 节点是红黑树节点，则通过红黑树分裂处理。
如果 e 节点是链表，以为 HashMap 是成倍扩容，这样原来位置的链表的节点们，会被分散到新的 table 的两个位置中去。可能这里对于不熟悉位操作的胖友有点难理解

**树化为什么阈值是 8**
先说树化缺点：
1.  树化后会有2倍空间占用
2.  在长度较小情况下，红黑树的查找性能和链表相差不大。
因此，树化不一定好，只有在**链表足够长**时才有显著效果。由此提出以下两个原则：
- 原则1：从单个链表角度看待树化
链表长则意味着hash冲突很激烈了，一个好的hash算法不应该有这么多冲突，说明此时元素很多，需要树化。

链表短时应该让树化情况尽量少发生 =\> 参考泊松概率函数，链表长度达到 **8** 的概率是0.00000006（hash冲突了8次），这就是为什么选择了8。
- 原则2：从整个table角度看待树化:
当整个table容量大于等于**64**时，说明也堆积有很多元素了，应该进行树化。
总结：**看hash冲突是否激烈（树是否够长）**

