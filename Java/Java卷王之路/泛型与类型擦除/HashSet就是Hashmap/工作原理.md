---
title: 工作原理
updated: 2023-02-23T09:41:01
created: 2022-05-16T15:22:40
---

1.7：数组 + 链表；1.8：数组 + 红黑树
**拉链法的工作原理**
HashMap\<String, String\> map = new HashMap\<\>()；map.put("K1", "V1")；map.put("K2", "V2")；map.put("K3", "V3");
1.  插入"K1", "V1"键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。
2.  插入"K2", "V2"键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。
3.  插入"K3", "V3"键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在"K2", "V2"**前面**。（1.7头插法）
HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过**强制指定一个桶**下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。

**容量2^n时，可以使用位运算提升性能**
使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。
我们知道，**位运算**的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。当计算hash值时，如果**容量为2的n次方**，则与运算和取模的效果一样！

扩容使用resize()实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。

**链表转红黑树**
从 JDK 1.8 开始，一个桶存储的链表长度大于等于 8 ，且整个table至少有64个元素时，会将当前桶的链表转换为红黑树。

**与 Hashtable 的比较**
Hashtable使用 synchronized 来进行同步。
HashMap可以插入键为 null 的 Entry。
HashMap的迭代器是 fail-fast 迭代器。
HashMap不能保证随着时间的推移 Map 中的元素次序是不变的。

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
