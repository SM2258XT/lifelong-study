---
title: 参数动态化
updated: 2022-11-21T09:26:42
created: 2022-11-21T08:01:34
---

参数动态化
2022年11月21日
8:01

**怎样才能更好地使用线程池？**
1.  **是否可以不使用线程池**
使用线程池根本原因是为了提高并发性，那么是否可使用其他方案替代

Disruptor框架（避免申请任务时的连续争用）、Actor（无锁，不再使用悲观锁来解决资源竞争）、协程（与多线程结合使用不冲突）
1.  **数学公式严格推导**
调研了业界的一些线程池参数配置方案，并没有得出通用的线程池计算方式。

并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。
1.  **线程池参数动态化**
尽管经过很多谨慎评估，仍然不能确保一次性计算出来合适的参数，那么可以尝试将参数从代码中**迁移到分布式配置中心**上，实现线程池参数的动态配置实时生效！

**动态化线程池参数的整体设计**
1.  **简化配置**
只使用最核心的3个参数corePoolSize、maximumPoolSize，workQueue

（1）并行执行子任务，例如聚合页面，应该提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。

（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。
1.  **实现参数可修改**
二次封装线程池，允许线程池监听并同步外部消息，根据消息修改配置，将线程池的参数配置放在可视化平台侧而不是代码中，允许实时查看、修改线程池配置。
1.  **增加线程池监控**
帮助开发人员了解线程池状态
JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)

![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image2.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image3.png)![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image4.png)
