---
title: 行级锁：解决不可重复读
updated: 2022-10-17T12:23:49
created: 2022-10-15T15:16:01
---

行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新
行锁是**基于索引**加载的
行锁的特征：锁冲突概率低，并发性高，但是比较麻烦消耗CPU，会有死锁的情况出现。

**行级锁分类**
1.  记录锁 Record Locks
仅是锁定某条记录
1.  间隙锁 Gap Locks
开区间
1.  临键锁 Next-Key Locks
等于记录锁 + 间隙锁，范围也是合并后的左开右闭。
1.  插入意向锁 Insert Intention Locks（了解）

**两阶段锁协议**
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是直到事务结束时才释放。这个就是两阶段锁协议
如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的**锁尽量往后放**

**锁后放案例分析：**
假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：
1.  顾客A扣款
1.  影院B入账
1.  记录日志
分析：
对顾客购票业务并发影响最大的是2，因为顾客和影院是多对一模型。顾客可以自己慢慢扣钱。
事务顺序：
begin -\> 1 -\> 3 -\> 2（申请行锁） -\> commit

**行级锁可能出现死锁**
解决：
1.  等待直至超时。
超时时间可以通过参数innodb_lock_wait_timeout来设置
1.  发起死锁检测。
发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑
![](C:\Users\82609\AppData\Local\Temp\Java\pandoc/media/image1.png)
