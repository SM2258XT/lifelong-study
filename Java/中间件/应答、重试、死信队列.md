---
title: 应答、重试、死信队列
updated: 2022-10-28T15:57:22
created: 2022-10-02T10:08:35
---

**重试**
在 RabbitMQ 中，消费重试是由 Spring-AMQP 所封装提供的，死信队列是 RabbitMQ 自带的功能
触发过程：
正常消息投递 -\> 服务器出错并拒绝 -\> MQ重新投递 -\> 服务器出错并拒绝 -\> …(重试一定次数) -\> MQ投递至DLX -\> DLX投递给交换机
必要条件：
basic.nack、requeue=false
补充：一共有3种成功应答方式（实际还有无应答这种没有应答的方式等）
1.  Ack：肯定确认，消息成功处理，Broker可以放心丢弃该消息
2.  Nack：否定确认，Broker可能重试等。
3.  Reject：否定确认，但告诉Broker可以直接丢弃该消息。

**死信队列DLX**
DLX, Dead-Letter-Exchange。利用DLX, 当消息在一个队列中变成死信（dead message）之后，它能被重新publish到另一个Exchange，这个Exchange就是DLX。
死信队列并不是一种特殊的物理类型/数据类型，就只是一个普通队列，只是操作玩的比较花
死信队列存在原因可以是以下情况：
1.  人为投递。
例如分布式订单服务，某个订单锁定但未支付，不能一直锁定，因此可以投递到死信队列延时取消。
1.  TTL过期。
如果一条消息设置了 TTL 属性或者进入了设置TTL 属性的队列，那么这条消息如果在TTL 设置的时间内没有被消费，则会成为"死信"

如果同时配置了队列的TTL 和消息的TTL，那么较小的那个值将会被使用，有两种方式设置 TTL。
1.  Queue装不下了。
2.  服务端拒绝
base.nack 或者 base.reject

**消息TTL和队列TTL区别**
队列TTL
- 里面的消息到时会立即丢弃（或成为死信），在整个队列中任意时刻判断。
消息TTL
- 设置后，在队列中即使过期，也不会立即丢弃。因为消息是否过期**仅在即将分发给消费者时判断**！
也就是说，当只设置消息TTL，又恰好遇到消息积压时，过期消息会存活直积压结束

TTL = 0：除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。
TTL 不设置：永不过期
